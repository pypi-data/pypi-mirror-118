# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['sqlify']

package_data = \
{'': ['*']}

extras_require = \
{'postgresql': ['psycopg2-binary']}

setup_kwargs = {
    'name': 'sqlify',
    'version': '0.4.0',
    'description': 'A simple sql builder based on standard Python type hints.',
    'long_description': '# [Sqlify](https://github.com/masroore/Sqlify)\nThis project is a fork from [pg_simple](https://github.com/masroore/pg_simple), that tries to implement a standard SQL\npython type hinting interface.\nOther goals for this project is to support other types of databases like sqlite.\n\nThe [pg_simple](https://github.com/masroore/pg_simple) module provides a simple yet efficient layer over `psycopg2` providing Python API for common SQL functions, explicit and implicit transactions management and database connection pooling for single and multi-threaded applications.\n\n`pg_simple` is not intended to provide ORM-like functionality, rather to make it easier to interact with the PostgreSQL database from python code for direct SQL access using convenient wrapper methods. The module wraps the excellent `psycopg2` library and most of the functionality is provided by this behind the scenes.\n\nThe `pg_simple` module provides:\n\n* Simplified handling of database connections/cursor\n* Connection pool for single or multithreaded access\n* Python API to wrap basic SQL functionality: select, update, delete, join et al\n* Query results as python namedtuple and dict objects (using `psycopg2.extras.NamedTupleCursor` and `psycopg2.extras.DictCursor` respectively)\n* Debug logging support\n\n\n## Installation\n\nWith `pip` or `easy_install`:\n\n```pip install pg_simple```\n\nor:\n\n```easy_install pg_simple```\n\nor from the source:\n\n```python setup.py install```\n\n\n## 30 Seconds Quick-start Guide\n\n* Step 1: Initialize a connection pool manager using `pg_simple.config_pool()`\n* Step 2: Create a database connection and cursor by instantiating a `pg_simple.PgSimple` object\n\nHere\'s a pseudo-example to illustrate the basic concepts:\n\n```python\nimport pg_simple\n\nconnection_pool = pg_simple.config_pool(dsn=\'dbname=my_db user=my_username ...\')\n\nwith pg_simple.PgSimple(connection_pool) as db:\n    db.insert(\'table_name\',\n              data={\'column\': 123,\n                    \'another_column\': \'blah blah\'})\n    db.commit()\n\nwith pg_simple.PgSimple(connection_pool) as db1:\n    rows = db1.fetchall(\'table_name\')\n```\n\n\n## Connection pool management\n\n### Initialize the connection pool\n\n\n```python\nimport pg_simple\n\nconnection_pool = pg_simple.config_pool(max_conn=250,\n                      expiration=60, # idle timeout = 60 seconds\n                      host=\'localhost\',\n                      port=5432,\n                      database=\'pg_simple\',\n                      user=\'postgres\',\n                      password=\'secret\')\n```\n\nor, using `dsn`:\n\n```python\nconnection_pool = pg_simple.config_pool(max_conn=250,\n                      expiration=60,\n                      dsn=\'dbname=database_name user=postgres password=secret\')\n\n```\n\nor, using `db_url`:\n\n```python\nconnection_pool = pg_simple.config_pool(max_conn=250,\n                      expiration=60,\n                      db_url= \'postgres://username:password@hostname:numeric_port/database\')\n\n```\n\nThe above snippets will create a connection pool capable of accommodating a maximum of 250 concurrent database connections. Once that limit is reached and the pool does not contain any idle connections, all subsequent new connection request will result in a `PoolError` exception (until the pool gets refilled with idle connections).\n\nTake caution to properly clean up all `pg_simple.PgSimple` objects after use (wrap the object inside python try-finally block or `with` statement). Once the object is released, it will quietly return the internal database connction to the idle pool. Failure to dispose `PgSimple` properly may result in pool exhaustion error.\n\n### Configure multiple connection pools\nTo generate different connection pools simply define each connection:\n\n```python\nconnection_pool_1 = pg_simple.config_pool(max_conn=250,\n                      expiration=60,\n                      dsn=\'dbname=database_name_1 user=postgres1 password=secret1\')\n\nconnection_pool_2 = pg_simple.config_pool(max_conn=250,\n                      expiration=60,\n                      dsn=\'dbname=database_name_2 user=postgres2 password=secret2\')\n\n```\n\nAfter that you can use each connection pool object to generate connections to the databases as you would with only one connection.\nYou can define as many of connection pool objects as your systems can handle and also both types (`SimpleConnectionPool` and `ThreadedConnectionPool`) at the same time.\n\n\n### Configure connection pool for thread-safe access\n\nThe default `SimpleConnectionPool` pool manager is not thread-safe. To utilize the connection pool in multi-threaded apps, use the `ThreadedConnectionPool`:\n\n```python\nconnection_pool = pg_simple.config_pool(max_conn=250,\n                      expiration=60,\n                      pool_manager=ThreadedConnectionPool,\n                      dsn=\'...\')\n```\n\n\n### Disable connection pooling\n\nTo disable connection pooling completely, set the `disable_pooling` parameter to True:\n\n```python\nconnection_pool = pg_simple.config_pool(disable_pooling=True, dsn=\'...\')\n```\n\nAll database requests on this pool will create new connections on the fly, and all connections returned to the pool (upon disposal of `PgSimple` object or by explicitly invoking `pool.put_conn()`) will be discarded immediately.\n\n\n\n\n### Garbage collect stale connections\n\nTo explicitly purge the pool of stale database connections (whose duration of stay in the pool exceeds the `expiration` timeout), invoke the `pool.purge_expired_connections()` method:\n\n```python\nconnection_pool.purge_expired_connections()\n```\n\nNote that the pool is automatically scavenged for stale connections when an idle connection is returned to the pool (using the `pool.put_conn()` method).\n\n\n## Basic Usage\n\n### Connecting to the posgtresql server\n\nThe following snippet will connect to the posgtresql server and allocate a cursor:\n\n```python\nimport sys\nimport pg_simple\n\ndb = pg_simple.PgSimple(log=sys.stdout,\n                        log_fmt=lambda x: \'>> %s\' % (x if isinstance(x, str) else x.query),\n                        nt_cursor=True)\n```\n\nBy default `PgSimple` generates result sets as `collections.namedtuple` objects (using `psycopg2.extras.NamedTupleCursor`). If you want to access the retrieved records using an interface similar to the Python dictionaries (using `psycopg2.extras.DictCursor`), set the `nt_cursor` parameter to `False`:\n\n```python\ndb = pg_simple.PgSimple(connection_pool, nt_cursor=False)\n```\n\n### Raw SQL execution\n\n```python\n>>> db.execute(\'SELECT tablename FROM pg_tables WHERE schemaname=%s and tablename=%s\', [\'public\', \'books\'])\n<cursor object at 0x102352a50; closed: 0>\n```\n\n### Dropping and creating tables\n\n```python\ndb.drop(\'books\')\n\ndb.create(\'books\',\n          \'\'\'\n"id" SERIAL NOT NULL,\n"type" VARCHAR(20) NOT NULL,\n"name" VARCHAR(40) NOT NULL,\n"price" MONEY NOT NULL,\n"published" DATE NOT NULL,\n"modified" TIMESTAMP(6) NOT NULL DEFAULT now()\n\'\'\'\n)\n\ndb.execute(\'\'\'ALTER TABLE "books" ADD CONSTRAINT "books_pkey" PRIMARY KEY ("id")\'\'\')\ndb.commit()\n\n```\n\n### Emptying a table or set of tables\n\n```python\ndb.truncate(\'tbl1\')\ndb.truncate(\'tbl2, tbl3\', restart_identity=True, cascade=True)\ndb.commit()\n```\n\n### Inserting rows\n\n```python\nfor i in range(1, 10):\n    db.insert("books",\n              {"genre": "fiction",\n               "name": "Book Name vol. %d" % i,\n               "price": 1.23 * i,\n               "published": "%d-%d-1" % (2000 + i, i)})\n\ndb.commit()\n```\n\n### Updating rows\n\n```python\nwith pg_simple.PgSimple(connection_pool) as db1:\n    db1.update(\'books\',\n               data={\'name\': \'An expensive book\',\n                     \'price\': 998.997,\n                     \'genre\': \'non-fiction\',\n                     \'modified\': \'NOW()\'},\n               where=(\'published = %s\', [datetime.date(2001, 1, 1)]))\n               \n    db1.commit()\n```\n\n### Deleting rows\n\n```python\ndb.delete(\'books\', where=(\'published >= %s\', [datetime.date(2005, 1, 31)]))\ndb.commit()\n```\n\n### Inserting/updating/deleting rows with return value\n\n```python\nrow = db.insert("books",\n                {"type": "fiction",\n                 "name": "Book with ID",\n                 "price": 123.45,\n                 "published": "1997-01-31"},\n                returning=\'id\')\nprint(row.id)\n\nrows = db.update(\'books\',\n                 data={\'name\': \'Another expensive book\',\n                       \'price\': 500.50,\n                       \'modified\': \'NOW()\'},\n                 where=(\'published = %s\', [datetime.date(2006, 6, 1)]),\n                 returning=\'modified\')\nprint(rows[0].modified)\n\nrows = db.delete(\'books\', \n                 where=(\'published >= %s\', [datetime.date(2005, 1, 31)]), \n                 returning=\'name\')\nfor r in rows:\n    print(r.name)\n```\n\n### Fetching a single record\n\n```python\nbook = db.fetchone(\'books\', \n                   fields=[\'name\', \'published\'], \n                   where=(\'published = %s\', [datetime.date(2002, 2, 1)]))\n                   \nprint(book.name + \'was published on \' + book[1])\n```\n\n### Fetching multiple records\n\n```python\nbooks = db.fetchall(\'books\',\n                    fields=[\'name AS n\', \'genre AS g\'],\n                    where=(\'published BETWEEN %s AND %s\', [datetime.date(2005, 2, 1), datetime.date(2009, 2, 1)]),\n                    order=[\'published\', \'DESC\'], \n                    limit=5, \n                    offset=2)\n\nfor book in books:\n    print(book.n + \'belongs to \' + book[1])\n```\n\n### Explicit database transaction management\n\n```python\nwith pg_simple.PgSimple(connection_pool) as _db:\n    try:\n        _db.execute(\'Some SQL statement\')\n        _db.commit()\n    except:\n        _db.rollback()\n```\n\n### Implicit database transaction management\n\n```python\nwith pg_simple.PgSimple(connection_pool) as _db:\n    _db.execute(\'Some SQL statement\')\n    _db.commit()\n```\n\nThe above transaction will be rolled back automatically should something goes awry.\n',
    'author': 'Gabriel Massadas',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/G4brym/sqlify',
    'packages': packages,
    'package_data': package_data,
    'extras_require': extras_require,
    'python_requires': '>=3.7.0,<4.0.0',
}


setup(**setup_kwargs)
