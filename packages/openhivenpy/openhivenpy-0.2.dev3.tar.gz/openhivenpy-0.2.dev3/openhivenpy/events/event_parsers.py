"""
Event parsers which handle events, validate data, format data and add an event
to the buffer to be executed (call all its listeners)

---

Under MIT License

Copyright Â© 2020 - 2021 Luna Klatzer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
from __future__ import annotations

import logging
from copy import deepcopy
from typing import Optional, Tuple, TYPE_CHECKING, Dict, Coroutine

from .. import types
from ..base_types import HivenObject
from ..gateway import DynamicEventBuffer

if TYPE_CHECKING:
    from ..client import HivenClient
    from ..client import ClientCache

__all__ = [
    'HivenParsers',
    'format_event_as_listener'
]

logger = logging.getLogger(__name__)


def format_event_as_listener(event: str) -> str:
    """
    Formats the passed event as an listener function in the following style:

        on_<lowercase_event_name>

    """
    return 'on_' + event.lower().replace('on_', '')


class HivenParsers(HivenObject):
    """
    Event Parsers for Hiven Events that validate and update the cached data
    """

    def __init__(self, client):
        self.client: HivenClient = client

    @property
    def storage(self) -> Optional[ClientCache]:
        """ 
        Returns the cached storage """
        return getattr(self.client, 'storage', None)

    def _get_from_client_buffer(
            self,
            event: str,
            args: Optional[tuple] = None,
            kwargs: Optional[dict] = None
    ):
        return self.client.message_broker.get_buffer(
            event,
            args,
            kwargs
        )

    async def dispatch(self, event: str, data: dict) -> Tuple[list, dict]:
        """
        Dispatches the parser and returns the args and kwargs. Note that this
        will only add the event to the buffer and NOT execute it. The asyncio
        event loop will run it as soon as the

        :param event: Event name that should be called
        :param data: Raw WebSocket Data that should be passed
        :return: The args and kwargs that were created with the parser
        """
        # getting the method from self
        coro = getattr(self, format_event_as_listener(event), None)

        if callable(coro):
            new_data: dict = deepcopy(data)
            return await coro(new_data)
        else:
            logger.warning(f"[EVENTS] Parser for event {event} was not found!")

    # Implementation of parsers that handle the events and add to the buffer
    # the args and kwargs for the event listeners

    async def on_user_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """ 
        EVENT: USER_UPDATE

        LISTENER: on_user_update

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        old_user_data = self.storage['users'][data['id']]  # cached data
        old_user = types.User(old_user_data, self.client)

        user_data = self.storage.add_or_update_user(data)
        new_user = types.User(user_data, self.client)

        # Parameter that will be passed to the assigned listener
        args: Tuple[types.User, types.User] = (old_user, new_user)
        kwargs: Dict = {}

        buffer: DynamicEventBuffer = self._get_from_client_buffer(
            'user_update'
        )
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_join(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_JOIN

        LISTENER: on_house_join

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        self.storage.add_or_update_house(data)

        new_house_data = types.House.format_obj_data(data)
        new_house = types.House(new_house_data, self.client)

        # Parameter that will be passed to the assigned listener
        args: Tuple[types.House] = \
            tuple([new_house])  # avoiding warning bc of singular tuple item
        kwargs: Dict = {}

        buffer = self._get_from_client_buffer('house_join')
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_UPDATE

        LISTENER: on_house_update

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        old_house_data = self.storage['houses'][data['id']]
        old_house = types.House(old_house_data, self.client)

        new_house_data = self.storage.add_or_update_house(data)
        new_house = types.House(new_house_data, self.client)

        # Parameter that will be passed to the assigned listener
        args: Tuple[types.House, types.House] = (old_house, new_house)
        kwargs: Dict = {}

        buffer = self._get_from_client_buffer('house_update')
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_down(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_DOWN

        LISTENER: Both for py-events house_down and house_delete.
        If property 'unavailable' of the dictionary is *false* it's
        house_delete

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        if data.get('unavailable') is True:
            buffer = self._get_from_client_buffer('house_down')
        else:
            buffer = self._get_from_client_buffer('house_delete')
            self.storage.remove_house(data['house_id'])

        # Parameter that will be passed to the assigned listener
        args: Tuple = tuple([data['house_id']])
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_leave(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_LEAVE

        LISTENER: on_house_leave

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        self.storage.remove_house(data['house_id'])

        # Parameter that will be passed to the assigned listener
        args: Tuple = tuple([data['house_id']])
        kwargs: Dict = {}

        buffer = self._get_from_client_buffer('house_leave')
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_room_create(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: ROOM_CREATE

        LISTENER: on_room_create

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('room_create')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_room_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: ROOM_UPDATE

        LISTENER: on_room_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('room_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_room_delete(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: ROOM_DELETE

        LISTENER: on_room_delete

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('room_delete')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_member_join(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_MEMBER_JOIN

        LISTENER: on_house_member_join

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_member_join')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_member_leave(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_MEMBER_LEAVE

        LISTENER: on_house_member_leave

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_member_leave')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    def on_house_member_online(self, data: dict) -> Coroutine:
        """
        EVENT: HOUSE_MEMBER_ENTER

        LISTENER: on_house_member_online

        Alias for on_house_member_enter

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        return self.on_house_member_enter(data)

    async def on_house_member_enter(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_MEMBER_ENTER

        LISTENER: on_house_member_online

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_member_online')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    def on_house_member_offline(self, data: dict) -> Coroutine:
        """
        EVENT: HOUSE_MEMBER_EXIT

        LISTENER: on_house_member_offline

        Alias for on_house_member_offline

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        return self.on_house_member_exit(data)

    async def on_house_member_exit(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_MEMBER_EXIT

        LISTENER: on_house_member_offline

        House user went offline. Triggers in every house the client,
        and the user is in the event

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_member_offline')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_member_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_MEMBER_UPDATE

        LISTENER: on_house_member_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_member_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_member_chunk(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_MEMBER_CHUNK

        LISTENER: on_house_member_chunk

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_member_chunk')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_batch_house_member_update(
            self, data: dict
    ) -> Tuple[Tuple, Dict]:
        """
        EVENT: BATCH_HOUSE_MEMBER_UPDATE

        LISTENER: on_batch_house_member_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('batch_house_member_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_house_entity_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: HOUSE_ENTITY_UPDATE

        LISTENER: on_house_entity_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('house_entity_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_relationship_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: RELATIONSHIP_UPDATE

        LISTENER: on_relationship_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('relationship_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_presence_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: PRESENCE_UPDATE

        LISTENER: on_presence_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('presence_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_message_create(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: MESSAGE_CREATE

        LISTENER: on_message_create

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('message_create')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_message_update(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: MESSAGE_UPDATE

        LISTENER: on_message_update

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('message_update')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_message_delete(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: MESSAGE_DELETE

        LISTENER: on_message_delete

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('message_delete')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    async def on_typing_start(self, data: dict) -> Tuple[Tuple, Dict]:
        """
        EVENT: TYPING_START

        LISTENER: on_typing_start

        **No data passed at the moment. Gives empty args and kwargs**

        *This parser method modifies the Client cache!*

        :returns: Args and Kwargs generated by the Parser
        """
        buffer = self._get_from_client_buffer('typing_start')
        # Parameter that will be passed to the assigned listener
        args: Tuple = ()
        kwargs: Dict = {}
        buffer.add_new_event(data, args, kwargs)
        return args, kwargs

    # TODO! Add role_update
