# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['sisifo', 'sisifo_common']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'sisifo',
    'version': '0.1.1',
    'description': 'Generic framework for running data pipelines',
    'long_description': 'image::./logo/logo.png[Sisyphus silhouette]\n\n\n== Sísifo - Task runner\n\nSísifo is the Spanish form of Sisyphus, in ancient Greek: Σίσυφος. This poor\nguy was punished for his self-aggrandizing craftiness and deceitfulness by\nbeing forced to roll an immense boulder up a hill only for it to roll down\nevery time it neared the top, repeating this action for eternity. More\ninformation in https://en.wikipedia.org/wiki/Sisyphus[Wikipedia].\n\nThis poor library is doomed to an eternity of performing tasks with no other\npurpose in its pitiful and miserable life. I hope you didn\'t make fun of this\ninsignificant library, our existence is not much more encouraging...\n\n\n=== How does it work?\n\nEssentially, Sísifo is just a library that allows you to run tasks on a data\ncollection. Therefore, the most important classes of the library are:\n\n* `sisifo.DataCollection`. A DataCollection is like a dictionary. Use a key to\nstore/retrieve any kind of value from a data collection. The values stored in a\ndata collection are called **entities**.\n* `sisifo.Task`. A task is a class with a `run(data_collection)` method that,\nusually, modifies the entities in a data collection.\n\nLet\'s dive into an example. The fist step is to import the core of the library.\nIt\'s as simple as:\n\n[source,python]\n----\nimport sisifo\n----\n\nYou can access all the relevant classes from the core of sisifo just with one\nimport. Everything else is optional, an extension of the core.\n\nLet\'s create our first data collection with a couple of entities.\n\n[source,python]\n----\ndata = sisifo.DataCollection()\ndata["entity1"] = 1\ndata["entity2"] = 2\n----\n\nAs you can see, a data collection has the same interface as a dictionary.\nTry to use `keys()`, `items()` or `<str> in data`:\n\n[source,python]\n----\ndata.keys()  # KeysView({\'entity1\': 1, \'entity2\': 2})\ndata.items()  # ItemsView({\'entity1\': 1, \'entity2\': 2})\n"entity1" in data  # True\n"entity3" in data  # False\n----\n\nNothing fancy so far, uh? Just a dictionary.\n\nImagine you want to add 1 to the `entity1`. You can do something like\n`data["entity1"] += 1` or we can use a `sisifo.Task` for this.\n\n[source,python]\n----\nclass AddOne(sisifo.Task):\n    def run(self, data):\n        data["entity1"] += 1\n----\n\nOn the one hand we have the data (`data` variable) and, on the other hand, we\nhave an operation defined inside a class (`AddOne` class). If we want to run a\ntask over a concrete data collection we need to call the `run` method in an\nobject of the class:\n\n[source,python]\n----\ntask = AddOne()\n\nprint(data)  # {\'entity1\': 1, \'entity2\': 2}\ntask.run(data)\nprint(data)  # {\'entity1\': 2, \'entity2\': 2}\n----\n\nWe wrote a really specific transformation, it only works for a given entity\nname `entity1`, what if we want to reuse the task also for adding one to the\n`entity2`? Instead of using a hard-coded entity name in the run method we can\ncreate a property in the `AddOne` class.\n\n[source,python]\n----\nclass AddOne(sisifo.Task):\n    def __init__(self, entity, **kwargs):\n        super().__init__(**kwargs)  # this is needed to initialize the super\n                                    # class sisifo.Task\n        self.entity = entity\n\n    def run(self, data):\n        data[self.entity] += 1\n----\n\nNow we can reuse the same task on different entities:\n\n[source,python]\n----\ndata = sisifo.DataCollection()\ndata["entity1"] = 1\ndata["entity2"] = 2\n\ntask1 = AddOne("entity1")\ntask2 = AddOne("entity2")\n\nprint(data)  # {\'entity1\': 1, \'entity2\': 2}\ntask1.run(data)\ntask2.run(data)\nprint(data)  # {\'entity1\': 2, \'entity2\': 3}\n----\n\nInstead of running all tasks one by one we can use a pipeline. A pipeline is\nan extension of the core sisifo code, so we need to import the common namespace\nand create the task from there:\n\n[source,python]\n----\nimport sisifo.namespaces.common as common_tasks\n\n\ndata = sisifo.DataCollection()\ndata["entity1"] = 1\ndata["entity2"] = 2\n\npipe = common_tasks.Pipeline([\n    AddOne("entity1"),\n    AddOne("entity2"),\n])\n\nprint(data)  # {\'entity1\': 1, \'entity2\': 2}\npipe.run(data)\nprint(data)  # {\'entity1\': 2, \'entity2\': 3}\n----\n\nCan we easily read a definition of this pipeline from a configuration file? Yes!\nsisifo has a decorator that allows you to register a class in the sisifo task\nregister and you can easily create instances from that class using a dynamic\napproach, that is, reading the name of the class from a string instead of calling\nthe specific class, like: `sisifo.create_task(dict(task="AddOne", entity="entity1"))`.\nexplain concepts of namespaces... TO BE CONTINUED.\n\n\n== Can Sísifo do X?\n\nIf you have any concerns about whether or not sisifo can do anything, think\nabout the answer to this other question: *Can Python do X?*.  If you can do it\nwith Python it means it can be done using sísifo. Maybe not out-of-the-box with\nthe existing tasks, but you can do it for sure after some development.\n\nSisifo is just a way of calling functions one after another. I think the main\nadvantages of the sisifo approach is that you are some kind forced to split you\ncode in small reusable pieces of code (tasks) and you can run those tasks just\nreading from a configuration file.\n',
    'author': 'guiferviz',
    'author_email': 'guiferviz@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/guiferviz/sisifo',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
